const express = require('express');
const cors = require('cors');
const { Pool } = require('pg');
const path = require('path');
const fs = require('fs');

const app = express();
const PORT = 1117;

// PostgreSQL
const pool = new Pool({ database: 'vistaview', host: 'localhost', port: 5432, max: 20 });

pool.query('SELECT NOW()')
  .then(() => console.log('âœ… PostgreSQL connected'))
  .catch(e => console.error('âŒ PostgreSQL error:', e.message));

// Middleware
app.use(cors({ origin: '*' }));
app.use(express.json({ limit: '100mb' }));
app.use(express.static(__dirname));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function ensureTodayStats() {
  await pool.query(`
    INSERT INTO learning_stats (stat_date)
    VALUES (CURRENT_DATE)
    ON CONFLICT (stat_date) DO NOTHING
  `);
}

async function incrementStat(field, amount = 1) {
  await pool.query(`
    UPDATE learning_stats SET ${field} = ${field} + $1, updated_at = NOW()
    WHERE stat_date = CURRENT_DATE
  `, [amount]);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROUTES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

app.get('/api/health', (req, res) => res.json({ 
  status: 'ok', 
  version: '26.0-world-class',
  features: ['postgresql', 'pgvector', 'self-learning', 'empathy', 'voice-patterns']
}));

app.get('/dashboard', (req, res) => res.sendFile(path.join(__dirname, 'dashboard.html')));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DASHBOARD API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
app.get('/api/dashboard', async (req, res) => {
  try {
    // Get stats
    const stats = await pool.query(`SELECT * FROM learning_stats ORDER BY stat_date DESC LIMIT 1`);
    const s = stats.rows[0] || {};
    
    // Get table counts
    const counts = await pool.query(`
      SELECT 
        (SELECT COUNT(*) FROM ai_memories) as memories,
        (SELECT COUNT(*) FROM voice_patterns) as voice_patterns,
        (SELECT COUNT(*) FROM user_interactions) as user_interactions,
        (SELECT COUNT(*) FROM crawled_sources) as crawled_sources,
        (SELECT COUNT(*) FROM crawled_market_prices) as market_prices,
        (SELECT COUNT(*) FROM empathy_patterns) as empathy_patterns,
        (SELECT COUNT(*) FROM knowledge_base) as knowledge,
        (SELECT COUNT(*) FROM vendor_profiles) as vendors,
        (SELECT COUNT(*) FROM product_catalog) as products,
        (SELECT SUM(pages_crawled) FROM crawled_sources) as total_pages_crawled
    `);
    const c = counts.rows[0];
    
    res.json({
      stats: {
        total_interactions: s.total_interactions || 0,
        learned_patterns: s.patterns_learned || 0,
        market_prices_learned: s.market_prices_learned || 0,
        web_crawls: parseInt(c.total_pages_crawled) || s.web_pages_crawled || 0,
        accuracy_score: s.accuracy_score || 85,
        empathy_patterns: parseInt(c.empathy_patterns) || 0,
        self_improvements: s.self_improvements || 0,
        last_updated: s.updated_at || new Date().toISOString()
      },
      tables: {
        memories: parseInt(c.memories) || 0,
        voice_patterns: parseInt(c.voice_patterns) || 0,
        user_interactions: parseInt(c.user_interactions) || 0,
        crawled_sources: parseInt(c.crawled_sources) || 0,
        market_prices: parseInt(c.market_prices) || 0,
        empathy_patterns: parseInt(c.empathy_patterns) || 0,
        knowledge: parseInt(c.knowledge) || 0,
        vendors: parseInt(c.vendors) || 0,
        products: parseInt(c.products) || 0
      }
    });
  } catch (e) {
    console.error('Dashboard error:', e);
    res.status(500).json({ error: e.message });
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TABLES API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
app.get('/api/tables', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT relname as name, n_live_tup as count
      FROM pg_stat_user_tables
      WHERE n_live_tup > 0
      ORDER BY n_live_tup DESC, relname
    `);
    res.json(result.rows);
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

app.get('/api/tables/:name', async (req, res) => {
  try {
    const name = req.params.name.replace(/[^a-z_]/g, '');
    const valid = await pool.query(`SELECT tablename FROM pg_tables WHERE schemaname='public' AND tablename=$1`, [name]);
    if (valid.rows.length === 0) return res.status(404).json({ error: 'Table not found' });
    
    const data = await pool.query(`SELECT * FROM ${name} ORDER BY created_at DESC LIMIT 100`);
    res.json({ name, count: data.rowCount, data: data.rows });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CRAWLED SOURCES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
app.get('/api/crawled-sites', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT id, url, domain, source_type, country, status, pages_crawled, last_crawled
      FROM crawled_sources ORDER BY pages_crawled DESC
    `);
    res.json(result.rows);
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LEARNING LOG (Memories)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
app.get('/api/memory', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT id, memory_type, category, key_concept, confidence_score, created_at
      FROM ai_memories ORDER BY created_at DESC LIMIT 100
    `);
    res.json(result.rows);
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VOICE PATTERNS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
app.get('/api/voice-patterns', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT * FROM voice_patterns ORDER BY times_used DESC, created_at DESC LIMIT 100
    `);
    res.json(result.rows);
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EMPATHY PATTERNS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
app.get('/api/empathy-patterns', async (req, res) => {
  try {
    const result = await pool.query(`SELECT * FROM empathy_patterns ORDER BY effectiveness_score DESC`);
    res.json(result.rows);
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VOICE COMMAND - LEARNING HAPPENS HERE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
app.post('/api/voice/command', async (req, res) => {
  const { command, context, intent } = req.body;
  console.log('[Voice]', command);
  
  try {
    await ensureTodayStats();
    
    // 1. Log interaction
    await pool.query(`
      INSERT INTO user_interactions (interaction_type, input_text, context, page_location)
      VALUES ('voice', $1, $2, $3)
    `, [command, JSON.stringify(context || {}), context?.page || 'unknown']);
    
    // 2. Learn pattern
    await pool.query(`
      INSERT INTO voice_patterns (pattern_type, input_text, intent, source)
      VALUES ('command', $1, $2, 'user')
      ON CONFLICT DO NOTHING
    `, [command, intent || 'unknown']);
    
    // 3. Store memory
    await pool.query(`
      INSERT INTO ai_memories (memory_type, category, key_concept, learned_data)
      VALUES ('interaction', 'voice', $1, $2)
    `, [command.substring(0, 100), JSON.stringify({ command, context, ts: new Date() })]);
    
    // 4. Update stats
    await pool.query(`
      UPDATE learning_stats SET 
        total_interactions = total_interactions + 1,
        voice_commands = voice_commands + 1,
        patterns_learned = patterns_learned + 1,
        updated_at = NOW()
      WHERE stat_date = CURRENT_DATE
    `);
    
    res.json({ success: true, learned: true });
  } catch (e) {
    console.error('Voice error:', e);
    res.json({ success: false, error: e.message });
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// QUERY ENDPOINT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
app.post('/api/query', async (req, res) => {
  const { query } = req.body;
  
  try {
    await ensureTodayStats();
    await incrementStat('total_interactions');
    
    if (query.toLowerCase().startsWith('select')) {
      const result = await pool.query(query);
      res.json({ query, count: result.rowCount, results: result.rows });
    } else {
      res.json({ query, message: 'Query logged' });
    }
  } catch (e) {
    res.json({ query, error: e.message });
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BACKUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
app.post('/api/backup', async (req, res) => {
  try {
    const memories = await pool.query('SELECT * FROM ai_memories LIMIT 1000');
    const patterns = await pool.query('SELECT * FROM voice_patterns');
    const knowledge = await pool.query('SELECT * FROM knowledge_base');
    const stats = await pool.query('SELECT * FROM learning_stats ORDER BY stat_date DESC LIMIT 1');
    
    const backup = {
      backup_date: new Date().toISOString(),
      stats: stats.rows[0],
      memories: memories.rows,
      voice_patterns: patterns.rows,
      knowledge: knowledge.rows
    };
    
    const file = path.join(__dirname, `backup-${Date.now()}.json`);
    fs.writeFileSync(file, JSON.stringify(backup, null, 2));
    
    res.json({ success: true, file });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

app.get('/api/vendors', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM vendor_profiles WHERE status = $1', ['active']);
    res.json(result.rows);
  } catch (e) { res.status(500).json({ error: e.message }); }
});

app.get('/api/products', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM product_catalog WHERE is_active = TRUE');
    res.json(result.rows);
  } catch (e) { res.status(500).json({ error: e.message }); }
});

app.get('/api/notifications', (req, res) => res.json([]));
app.get('/api/ai/training/stats', async (req, res) => {
  try {
    const r = await pool.query('SELECT * FROM learning_stats ORDER BY stat_date DESC LIMIT 1');
    res.json({ stats: r.rows[0] || {} });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// START
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
app.listen(PORT, async () => {
  console.log('');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('  ğŸŒŸ VISTAVIEW WORLD-CLASS AGENTIC AI v26.0');
  console.log(`  http://localhost:${PORT}`);
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('');
  console.log('  Features:');
  console.log('  âœ… PostgreSQL primary database');
  console.log('  âœ… pgvector for embeddings');
  console.log('  âœ… Voice pattern learning');
  console.log('  âœ… Human empathy patterns');
  console.log('  âœ… Web crawl data');
  console.log('  âœ… Self-learning system');
  console.log('');
  
  await ensureTodayStats();
});
